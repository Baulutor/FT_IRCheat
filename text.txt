IRC: (internet relay chat) protocole de communication en temp reel.


client IRC : le client IRC est le programme pour nous connecter a un serveur IRC. il etablie une connexion avec le serveur via un socket.


serveur IRC : le serveur IRC est le logiciel qui gere les connexions des client IRC. il etablie une connexion avec le client via un socket.


socket : fonction qui permet de creer un point de communication bidirectionnel entre le client IRC et le serveur IRC.
- int socketfd = socket(AF_INET, SOCK_STREAM, 0);
socketfd : fd du socket
domaine (protocole de transmition)      AF_INET : IPv4
                                        AF_INET6 : IPv6

type (mode de transmition)              SOCK_STREAM : TPC

protocole (protocole a utiliser)        0 : le protocole approprie sera choisi automatiquement



setsockopt : fonction systeme pour definir des options de socket tels que le temps d'attente, la reutilisation de l'addresse, le temponde reception d'envoie etc...
- setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse))
socketfd : fd du socket
SOL_SOCKET : option qui indique que l'option s'applique au socket lui meme.
SO_REUSEADDR : nom de l'option
&reuse : ref vers les donnees contenant la nouvellle valeur de l'option.
sizeof(reuse) : la taille des donnees pointees par &reuse.


getsockname : fonction systeme pour obtenir les informations sur l'adresse locale associee a un socket.
- getsockname(sockfd, (struct sockaddr*)&local_addr, &addr_len)
soketfd : fd du socket
(struct sockaddr*)&local_addr : pointeur vers une struct sockaddr dans laquelle les informations sur l'adresse locale
&addr_len : ref vers un int qui specifie la taille de la struct &local_addr en octets


getprotobyname :fonction qui permet d'obtenir des informations sur un protocole reseau a partir de son nom. la fonction retourne une struct "protoent" avec son numereau de protocole etc...
- struct protoent* protocol = getprotobyname("tcp");


getaddrinfo : permet d'obtenir des informations sur les adresse reseau avant de creer un socket ou etablir une connection reseau
const char* hostname = "www.example.com"; // Nom d'hôte à résoudre
const char* service = "http"; // Service à résoudre (nom de service ou numéro de port)
// Options pour la recherche d'adresses
struct addrinfo hints;
// Appel à getaddrinfo() pour obtenir des informations sur les adresses réseau
struct addrinfo* result;
int status = getaddrinfo(hostname, service, &hints, &result);


freeaddrinfo : permet de liberer la memoire par la fonction getaddrinfo
-void freeaddrinfo(struct addrinfo *res);
res : pointeur vers la struct addrinfo


bind : permet de lier un socket a une adresse ip et a un port sur lequelle le serveur ecoutera les connexions entrantes.
- int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
sockfd : fd du socket
addr : pointeur vers une struct sockaddr contentant l'adresse a laquelle lier le socket
socklen_t addrlen : la taille de la stuct socketaddr en octets


connect : permet d'etablir une connexion vers une adresse distante a partir d'un socket
- int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
socketfd : fd du socket
addr : pointeur vers une structure socketaddr conteant l'adresse a laquelle se connecter.
addrlen : la taille de la struc en octets.


listen : permet de placer un socket en mode ecoute afinqu'il puisse accepter les connexions entrantes.
- int listen(int sockfd, int backlog);
socketfd : fd du socket
backlog : la taille de la file d'attente pour les connexions en attente


accept : accept une nouvelle connexion entrante sur un socket serveur, creant un nouveau socket pour la connexion.
- int newSocket = accept(serverSocket, (struct sockaddr *)&clientAddress, &addressLength);
socketfd : fd du socket
(struct sockaddr *)&clientAddress : struct qui contient les informations sur le client connecte
&addressLength : taile de la struct 'clientAddress'

htons : converti l'ordre des octets (16 bits )d'un entier court non signe de l'ordre hote a l'ordre reseau.
- unsigned short networkPort = htons(hostPort)
networkPort : l'ordre standardise utiliser sur les reseaux
hostPort : l'ordre de l'ordinateur sur lequel le prog tourne.

htonl : pareil que htons mais en 32 bits
- unsigned long networkPort = htonl(hostPort)


ntohs : converti l'ordre des octets (16 bits )d'un entier court non signe de l'ordre resau a l'ordre hote.
- unsigned short hostPort = ntohs(networkPort)


ntohl : pareil que ntohs mais en 32 bits
- unsigned long hostPort = htonl(networkPort)


inet_addr : converti une string representant une adresse IPv4 en binaire.
in_addr_t ipAdress = inet_addr(ipAddressStr)
ipAdress : valeur en binaire d'une string representant une address IPv4 (192.168.1.1)
ipAddressStr : valeur en decimale d'une string representant une adress IPv4

inet_ntoa : fait l'inversse de inet_addr
in_addr ipAddress;
- ipAddress.s_addr = inet_addr("192.168.1.1");


send : permet d'envoyer des donnees sur un socket.
- ssize_t bytesSent send(int socket, const void *buffer, size_t length, int flags);
socket : fd du socket
buffer : pointeur vers le debut des donnees a envoyer
length : taile en octets des donnees a envoyer
flag : indicateurs specifiant le compotement de l'operation d'envoie
bytesSent : le nombre d'octets envoyes avec succes ou -1 en cas d'erreur


recv : permet de recevoir des donnees sun un socket
- ssize_t bytesReceived recv(int socket, void *buffer, size_t length, int flags);
socket : fd du socket
buffer : pointeur vers le debut des donnees a envoyer
length : taile en octets des donnees a envoyer
flag : indicateurs specifiant le compotement de l'operation d'envoie
bytesReceived : le nombre d'octets recu avec succes ou -1 en cas d'erreur


signal :

sigaction :

lseek :

fstat :

fcntl :

poll : surveille des fd pour detecter les evenement d'entree et sortie.
- int poll(struct pollfd fds[], nfds_t nfds, int timeout);
struct pollfd fds[] : un tableau d'objets 'struct pollfd' qui indique les fd a surveiller
nfds_t nfds : le nombre d'elements dans le tableau fds[]
int timeout : le delai pendant lequel poll() doit attendre q'un evenement se produise


select : surveille plusieurs fd de socket afin de determiner lesquels sont prets pour l'entree, la sortie ou les exceptions
- int fds select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
int nfds : nombres max de fd dans les ensembles 'readfds' 'writefds' 'exceptfds' plus 1.
fd_set *readfds : pointeur vers un ensembles de fd a surveiller pour les operations de lecture
fd_set *writefds : pointeur vers un ensembles de fd a surveiller pour les operations d'ecriture
fd_set *exceptfds : pointeur vers un ensembles de fd a surveiller pour les exceptions
struct timeval *timeout : pointeur vers une struct timeval specifiant le delai d'attente max pour le retoure de select.

connexion a IRC
allumer le serveur ./irc <port> <mdp>
nc -C <addr ip> <port>

** PASS <mdp du serveur>
** NICK <pseudo>
    regle a suivre pour le nickname
    - 9 char max
    - pas de string vide
    - pas de ',' ' ' '*' '?' '!' '@'
    - ne peu pas commencer par '#' '&' 


** USER <name> 0 * <nom complet>
** JOIN #<nom_du_chanel> (option <mdp>)     // on peu joindre plusieurs chan en meme temps ex : JOIN #<nom_du_chanel> (option <mdp>) + #<nom_du_chanel> (option <mdp>)
    regle du nom du chanel
    - 200 char max
    - commence par '#' ou '&'
    - pas de ' ' ','

** PRIVMSG #<nom_du_chanel> : <msg_a_ecrir>
** KICK #<nom_du_chanel> <NICK> (option <raison du kick>)
** INVITE <NICK> #<nom_du_chanel>
** TOPIC #<nom_du_chanel> [nom_du_topic]
** MODE #<nom_du_chanel> '-i' '-t' '-k' '-o' '-l'
